// üîç Code Analyzer - –ê–Ω–∞–ª—ñ–∑ –∫–æ–¥—É

class CodeAnalyzer {
    constructor() {
        this.securityPatterns = this.initSecurityPatterns();
        this.qualityPatterns = this.initQualityPatterns();
    }

    // ========================================
    // SECURITY ANALYSIS
    // ========================================

    initSecurityPatterns() {
        return [
            {
                name: 'eval',
                pattern: /eval\s*\(/gi,
                severity: 'critical',
                message: 'eval() –º–æ–∂–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –¥–æ–≤—ñ–ª—å–Ω–∏–π –∫–æ–¥',
                category: 'security'
            },
            {
                name: 'innerHTML',
                pattern: /\.innerHTML\s*=/gi,
                severity: 'high',
                message: 'innerHTML –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ XSS –∞—Ç–∞–∫',
                category: 'security'
            },
            {
                name: 'document.write',
                pattern: /document\.write\s*\(/gi,
                severity: 'medium',
                message: 'document.write() –∑–∞—Å—Ç–∞—Ä—ñ–ª–∞ —Ç–∞ –Ω–µ–±–µ–∑–ø–µ—á–Ω–∞',
                category: 'security'
            },
            {
                name: 'dangerouslySetInnerHTML',
                pattern: /dangerouslySetInnerHTML/gi,
                severity: 'high',
                message: '–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è dangerouslySetInnerHTML –±–µ–∑ —Å–∞–Ω—ñ—Ç–∏–∑–∞—Ü—ñ—ó',
                category: 'security'
            },
            {
                name: 'exec',
                pattern: /exec\s*\(/gi,
                severity: 'critical',
                message: 'exec() –º–æ–∂–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ —Å–∏—Å—Ç–µ–º–Ω—ñ –∫–æ–º–∞–Ω–¥–∏',
                category: 'security'
            },
            {
                name: 'localStorage password',
                pattern: /localStorage\.(setItem|getItem).*password/gi,
                severity: 'critical',
                message: '–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø–∞—Ä–æ–ª—ñ–≤ –≤ localStorage',
                category: 'security'
            },
            {
                name: 'http requests',
                pattern: /fetch\s*\([^)]*http:\/\//gi,
                severity: 'medium',
                message: '–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è HTTP –∑–∞–º—ñ—Å—Ç—å HTTPS',
                category: 'security'
            },
            {
                name: 'SQL injection',
                pattern: /query.*\+.*user|SELECT.*\+/gi,
                severity: 'critical',
                message: '–ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∞ SQL injection –≤—Ä–∞–∑–ª–∏–≤—ñ—Å—Ç—å',
                category: 'security'
            }
        ];
    }

    analyzeSecurity(code) {
        const issues = [];

        this.securityPatterns.forEach(({ name, pattern, severity, message, category }) => {
            const matches = code.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    const lineNumber = this.getLineNumber(code, match);
                    issues.push({
                        name,
                        severity,
                        message,
                        category,
                        match,
                        line: lineNumber
                    });
                });
            }
        });

        return issues;
    }

    // ========================================
    // CODE QUALITY ANALYSIS
    // ========================================

    initQualityPatterns() {
        return [
            {
                name: 'console.log',
                pattern: /console\.(log|warn|error|debug)/gi,
                severity: 'low',
                message: '–ó–∞–ª–∏—à–µ–Ω–æ console.log()',
                category: 'quality'
            },
            {
                name: 'debugger',
                pattern: /debugger;/gi,
                severity: 'low',
                message: '–ó–∞–ª–∏—à–µ–Ω–æ debugger',
                category: 'quality'
            },
            {
                name: 'TODO',
                pattern: /(TODO|FIXME|HACK|XXX):/gi,
                severity: 'info',
                message: '–ö–æ–º–µ–Ω—Ç–∞—Ä TODO/FIXME',
                category: 'quality'
            },
            {
                name: 'var keyword',
                pattern: /\bvar\s+/g,
                severity: 'low',
                message: '–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è var –∑–∞–º—ñ—Å—Ç—å let/const',
                category: 'quality'
            },
            {
                name: 'function length',
                pattern: null, // Custom check
                severity: 'medium',
                message: '–§—É–Ω–∫—Ü—ñ—è –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∞ (>50 —Ä—è–¥–∫—ñ–≤)',
                category: 'quality'
            }
        ];
    }

    analyzeQuality(code) {
        const issues = [];

        // Pattern-based checks
        this.qualityPatterns.forEach(({ name, pattern, severity, message, category }) => {
            if (!pattern) return;

            const matches = code.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    const lineNumber = this.getLineNumber(code, match);
                    issues.push({
                        name,
                        severity,
                        message,
                        category,
                        match,
                        line: lineNumber
                    });
                });
            }
        });

        // Check function length
        const functionLengthIssues = this.checkFunctionLength(code);
        issues.push(...functionLengthIssues);

        // Check complexity
        const complexityIssues = this.checkComplexity(code);
        issues.push(...complexityIssues);

        return issues;
    }

    // ========================================
    // CODE METRICS
    // ========================================

    getMetrics(code) {
        const lines = code.split('\n');
        
        return {
            totalLines: lines.length,
            codeLines: this.countCodeLines(code),
            commentLines: this.countCommentLines(code),
            blankLines: this.countBlankLines(code),
            functions: this.countFunctions(code),
            classes: this.countClasses(code),
            complexity: this.calculateComplexity(code),
            size: code.length,
            sizeFormatted: this.formatBytes(code.length)
        };
    }

    countCodeLines(code) {
        const lines = code.split('\n');
        return lines.filter(line => {
            const trimmed = line.trim();
            return trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('/*');
        }).length;
    }

    countCommentLines(code) {
        const singleLine = (code.match(/\/\/.*/g) || []).length;
        const multiLine = (code.match(/\/\*[\s\S]*?\*\//g) || [])
            .reduce((count, comment) => count + comment.split('\n').length, 0);
        return singleLine + multiLine;
    }

    countBlankLines(code) {
        const lines = code.split('\n');
        return lines.filter(line => line.trim() === '').length;
    }

    countFunctions(code) {
        const functionPatterns = [
            /function\s+\w+/g,
            /\w+\s*:\s*function/g,
            /=>\s*{/g,
            /const\s+\w+\s*=\s*\(/g
        ];

        let count = 0;
        functionPatterns.forEach(pattern => {
            const matches = code.match(pattern);
            if (matches) count += matches.length;
        });

        return count;
    }

    countClasses(code) {
        const classPattern = /class\s+\w+/g;
        const matches = code.match(classPattern);
        return matches ? matches.length : 0;
    }

    calculateComplexity(code) {
        // Simplified cyclomatic complexity
        const patterns = [
            /if\s*\(/g,
            /else\s+if/g,
            /for\s*\(/g,
            /while\s*\(/g,
            /case\s+/g,
            /catch\s*\(/g,
            /&&/g,
            /\|\|/g,
            /\?/g
        ];

        let complexity = 1;
        patterns.forEach(pattern => {
            const matches = code.match(pattern);
            if (matches) complexity += matches.length;
        });

        return complexity;
    }

    // ========================================
    // SPECIALIZED CHECKS
    // ========================================

    checkFunctionLength(code) {
        const issues = [];
        const functionRegex = /function\s+(\w+)[^{]*{([^}]*{[^}]*}[^}]*)*}/g;
        
        let match;
        while ((match = functionRegex.exec(code)) !== null) {
            const functionBody = match[0];
            const lines = functionBody.split('\n').length;
            
            if (lines > 50) {
                const lineNumber = this.getLineNumber(code, match[0]);
                issues.push({
                    name: 'long function',
                    severity: 'medium',
                    message: `–§—É–Ω–∫—Ü—ñ—è ${match[1]} –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∞ (${lines} —Ä—è–¥–∫—ñ–≤)`,
                    category: 'quality',
                    line: lineNumber
                });
            }
        }

        return issues;
    }

    checkComplexity(code) {
        const issues = [];
        const complexity = this.calculateComplexity(code);
        
        if (complexity > 10) {
            issues.push({
                name: 'high complexity',
                severity: 'medium',
                message: `–í–∏—Å–æ–∫–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –∫–æ–¥—É (${complexity})`,
                category: 'quality',
                line: 1
            });
        }

        return issues;
    }

    // ========================================
    // COMPLETE ANALYSIS
    // ========================================

    analyze(code, options = {}) {
        const {
            checkSecurity = true,
            checkQuality = true,
            getMetrics = true
        } = options;

        const result = {
            issues: [],
            metrics: null,
            summary: {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                info: 0
            }
        };

        // Security analysis
        if (checkSecurity) {
            const securityIssues = this.analyzeSecurity(code);
            result.issues.push(...securityIssues);
        }

        // Quality analysis
        if (checkQuality) {
            const qualityIssues = this.analyzeQuality(code);
            result.issues.push(...qualityIssues);
        }

        // Metrics
        if (getMetrics) {
            result.metrics = this.getMetrics(code);
        }

        // Count by severity
        result.issues.forEach(issue => {
            result.summary[issue.severity]++;
        });

        // Sort by severity
        const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
        result.issues.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

        return result;
    }

    // ========================================
    // REPORT GENERATION
    // ========================================

    generateReport(analysisResult) {
        const { issues, metrics, summary } = analysisResult;

        let report = 'üîç –ó–í–Ü–¢ –ê–ù–ê–õ–Ü–ó–£ –ö–û–î–£\n\n';

        // Summary
        report += 'üìä –ü–Ü–î–°–£–ú–û–ö:\n';
        report += `   üî¥ –ö—Ä–∏—Ç–∏—á–Ω—ñ: ${summary.critical}\n`;
        report += `   üü† –í–∏—Å–æ–∫—ñ: ${summary.high}\n`;
        report += `   üü° –°–µ—Ä–µ–¥–Ω—ñ: ${summary.medium}\n`;
        report += `   üü¢ –ù–∏–∑—å–∫—ñ: ${summary.low}\n`;
        report += `   ‚ÑπÔ∏è  –Ü–Ω—Ñ–æ: ${summary.info}\n\n`;

        // Metrics
        if (metrics) {
            report += 'üìà –ú–ï–¢–†–ò–ö–ò:\n';
            report += `   –í—Å—å–æ–≥–æ —Ä—è–¥–∫—ñ–≤: ${metrics.totalLines}\n`;
            report += `   –†—è–¥–∫—ñ–≤ –∫–æ–¥—É: ${metrics.codeLines}\n`;
            report += `   –ö–æ–º–µ–Ω—Ç–∞—Ä—ñ–≤: ${metrics.commentLines}\n`;
            report += `   –§—É–Ω–∫—Ü—ñ–π: ${metrics.functions}\n`;
            report += `   –ö–ª–∞—Å—ñ–≤: ${metrics.classes}\n`;
            report += `   –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å: ${metrics.complexity}\n`;
            report += `   –†–æ–∑–º—ñ—Ä: ${metrics.sizeFormatted}\n\n`;
        }

        // Issues
        if (issues.length > 0) {
            report += '‚ö†Ô∏è –ó–ù–ê–ô–î–ï–ù–Ü –ü–†–û–ë–õ–ï–ú–ò:\n\n';
            
            issues.forEach((issue, i) => {
                const icon = this.getSeverityIcon(issue.severity);
                report += `${i + 1}. ${icon} [${issue.severity.toUpperCase()}] ${issue.message}\n`;
                report += `   –†—è–¥–æ–∫: ${issue.line}\n`;
                if (issue.match) {
                    report += `   –ö–æ–¥: ${issue.match.substring(0, 50)}...\n`;
                }
                report += '\n';
            });
        } else {
            report += '‚úÖ –ü—Ä–æ–±–ª–µ–º –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!\n';
        }

        return report;
    }

    // ========================================
    // HELPERS
    // ========================================

    getLineNumber(code, searchString) {
        const index = code.indexOf(searchString);
        if (index === -1) return 0;
        
        return code.substring(0, index).split('\n').length;
    }

    getSeverityIcon(severity) {
        const icons = {
            critical: 'üî¥',
            high: 'üü†',
            medium: 'üü°',
            low: 'üü¢',
            info: '‚ÑπÔ∏è'
        };
        return icons[severity] || '‚ö™';
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// –ï–∫—Å–ø–æ—Ä—Ç
const codeAnalyzer = new CodeAnalyzer();
window.codeAnalyzer = codeAnalyzer;

// Backward compatibility
window.analyzeCode = (code) => codeAnalyzer.analyze(code);

console.log('‚úÖ Code Analyzer loaded');
