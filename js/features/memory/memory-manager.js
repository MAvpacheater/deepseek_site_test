// üß† Memory Manager Core - Main Logic (400 lines)

class MemoryManagerCore {
    constructor() {
        this.categories = ['–∑–∞–≥–∞–ª—å–Ω–µ', '–≤–∞–∂–ª–∏–≤–µ', '–∑–∞–≤–¥–∞–Ω–Ω—è', '–Ω–∞–≤—á–∞–Ω–Ω—è', '–ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–µ'];
        this.filterCategory = 'all';
        this.filterImportant = false;
        this.searchQuery = '';
        this.sortBy = 'date'; // 'date', 'importance', 'category'
        
        this.init();
    }

    // ========================================
    // –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø
    // ========================================

    init() {
        this.setupEventListeners();
        this.loadMemories();
        
        console.log('‚úÖ Memory Manager Core initialized');
    }

    setupEventListeners() {
        // EventBus –ø–æ–¥—ñ—ó
        if (window.eventBus) {
            eventBus.on('memory:add', () => this.refreshMemories());
            eventBus.on('memory:update', () => this.refreshMemories());
            eventBus.on('memory:delete', () => this.refreshMemories());
            eventBus.on('memory:clear', () => this.refreshMemories());
        }

        // AppState –ø–æ–¥—ñ—ó
        if (window.appState) {
            appState.on('memory:add', () => this.refreshMemories());
        }
    }

    // ========================================
    // –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –°–ü–û–ì–ê–î–Ü–í
    // ========================================

    async loadMemories() {
        try {
            let memories = [];

            // –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ IndexedDB
            if (window.storageManager) {
                memories = await storageManager.getMemories();
            }

            // –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É–≤–∞—Ç–∏ –∑ AppState
            if (window.appState && memories.length > 0) {
                appState.agent.memory = memories;
            }

            // Fallback –¥–æ AppState
            if (memories.length === 0 && window.appState) {
                memories = appState.getMemories();
            }

            // Fallback –¥–æ localStorage
            if (memories.length === 0) {
                const saved = localStorage.getItem('agent_memories');
                if (saved) {
                    try {
                        memories = JSON.parse(saved);
                    } catch (e) {
                        console.error('Failed to parse memories:', e);
                    }
                }
            }

            this.updateStats();
            this.refreshMemories();

            console.log(`üß† Loaded ${memories.length} memories`);

        } catch (error) {
            console.error('Failed to load memories:', error);
            if (window.errorHandler) {
                errorHandler.logError({
                    type: 'memory_error',
                    message: 'Failed to load memories',
                    error: error.message,
                    severity: 'medium'
                });
            }
        }
    }

    // ========================================
    // –°–¢–í–û–†–ï–ù–ù–Ø –°–ü–û–ì–ê–î–£
    // ========================================

    openCreateModal() {
        const modal = document.getElementById('memoryModal');
        if (!modal) return;

        // –û—á–∏—Å—Ç–∏—Ç–∏ —Ñ–æ—Ä–º—É
        this.resetForm();
        modal.classList.add('active');
    }

    resetForm() {
        const fields = {
            memoryTitle: '',
            memoryContent: '',
            memoryImportant: false
        };

        Object.entries(fields).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                if (typeof value === 'boolean') {
                    element.checked = value;
                } else {
                    element.value = value;
                }
            }
        });
    }

    async createMemory() {
        const title = document.getElementById('memoryTitle')?.value.trim();
        const content = document.getElementById('memoryContent')?.value.trim();
        const important = document.getElementById('memoryImportant')?.checked || false;

        // –í–∞–ª—ñ–¥–∞—Ü—ñ—è
        const validation = this.validateMemoryData({ title, content });
        if (!validation.valid) {
            if (window.showToast) {
                showToast(`‚ö†Ô∏è ${validation.errors.join(', ')}`, 'warning');
            }
            return null;
        }

        const memory = {
            id: Date.now(),
            title: title,
            content: content,
            category: this.detectCategory(title, content),
            important: important,
            tags: this.extractTags(content),
            timestamp: Date.now(),
            created: new Date().toISOString(),
            auto: false
        };

        try {
            // –î–æ–¥–∞—Ç–∏ –≤ AppState
            if (window.appState) {
                appState.addMemory(memory);
            }

            // –ó–±–µ—Ä–µ–≥—Ç–∏ –≤ IndexedDB
            if (window.storageManager) {
                await storageManager.saveMemory(memory);
            }

            // Backup –≤ localStorage
            await this.saveToLocalStorage();

            this.closeModal('memoryModal');
            this.refreshMemories();

            if (window.showToast) {
                showToast('‚úÖ –°–ø–æ–≥–∞–¥ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!', 'success');
            }

            return memory;

        } catch (error) {
            console.error('Failed to create memory:', error);
            if (window.showToast) {
                showToast('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è', 'error');
            }
            return null;
        }
    }

    // ========================================
    // –û–ù–û–í–õ–ï–ù–ù–Ø –°–ü–û–ì–ê–î–£
    // ========================================

    async editMemory(memoryId) {
        const memory = this.getMemory(memoryId);
        if (!memory) return;

        const modal = document.getElementById('memoryModal');
        if (!modal) return;

        // –ó–∞–ø–æ–≤–Ω–∏—Ç–∏ —Ñ–æ—Ä–º—É
        document.getElementById('memoryTitle').value = memory.title;
        document.getElementById('memoryContent').value = memory.content;
        document.getElementById('memoryImportant').checked = memory.important;

        // –ó–±–µ—Ä–µ–≥—Ç–∏ ID –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
        modal.dataset.editingId = memoryId;
        modal.classList.add('active');
    }

    async updateMemory(memoryId, updates) {
        try {
            const memories = this.getMemories();
            const memory = memories.find(m => m.id === memoryId);
            
            if (!memory) {
                throw new Error('Memory not found');
            }

            // –û–Ω–æ–≤–∏—Ç–∏ –¥–∞–Ω—ñ
            Object.assign(memory, updates, {
                updated: new Date().toISOString()
            });

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é —è–∫—â–æ –∑–º—ñ–Ω–∏–≤—Å—è –∫–æ–Ω—Ç–µ–Ω—Ç
            if (updates.title || updates.content) {
                memory.category = this.detectCategory(
                    memory.title, 
                    memory.content
                );
                memory.tags = this.extractTags(memory.content);
            }

            // –û–Ω–æ–≤–∏—Ç–∏ –≤ IndexedDB
            if (window.storageManager) {
                await storageManager.update(
                    storageManager.stores.memories, 
                    memory
                );
            }

            // Backup –≤ localStorage
            await this.saveToLocalStorage();

            this.refreshMemories();

            return memory;

        } catch (error) {
            console.error('Failed to update memory:', error);
            throw error;
        }
    }

    async toggleImportant(memoryId) {
        const memory = this.getMemory(memoryId);
        if (!memory) return false;

        memory.important = !memory.important;

        // –û–Ω–æ–≤–∏—Ç–∏
        await this.updateMemory(memoryId, { important: memory.important });

        if (window.showToast) {
            const msg = memory.important ? 
                '‚≠ê –î–æ–¥–∞–Ω–æ –≤ –≤–∞–∂–ª–∏–≤—ñ' : 
                '‚òÜ –ü—Ä–∏–±—Ä–∞–Ω–æ –∑ –≤–∞–∂–ª–∏–≤–∏—Ö';
            showToast(msg, 'success', 2000);
        }

        return true;
    }

    // ========================================
    // –í–ò–î–ê–õ–ï–ù–ù–Ø –°–ü–û–ì–ê–î–£
    // ========================================

    async deleteMemory(memoryId) {
        const memory = this.getMemory(memoryId);
        if (!memory) return false;

        // –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è
        const confirmed = await this.confirmDelete(memory);
        if (!confirmed) return false;

        try {
            // –í–∏–¥–∞–ª–∏—Ç–∏ –∑ AppState
            const memories = window.appState?.agent?.memory || [];
            const index = memories.findIndex(m => m.id === memoryId);
            if (index !== -1) {
                memories.splice(index, 1);
            }

            // –í–∏–¥–∞–ª–∏—Ç–∏ –∑ IndexedDB
            if (window.storageManager) {
                await storageManager.delete(
                    storageManager.stores.memories, 
                    memoryId
                );
            }

            // Backup –≤ localStorage
            await this.saveToLocalStorage();

            this.refreshMemories();

            if (window.showToast) {
                showToast('‚úÖ –°–ø–æ–≥–∞–¥ –≤–∏–¥–∞–ª–µ–Ω–æ', 'success');
            }

            return true;

        } catch (error) {
            console.error('Failed to delete memory:', error);
            if (window.showToast) {
                showToast('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è', 'error');
            }
            return false;
        }
    }

    async confirmDelete(memory) {
        if (window.modalManager) {
            return await modalManager.confirm(
                `–í–∏–¥–∞–ª–∏—Ç–∏ —Å–ø–æ–≥–∞–¥ "${memory.title}"?\n\n–¶—é –¥—ñ—é –Ω–µ –º–æ–∂–Ω–∞ —Å–∫–∞—Å—É–≤–∞—Ç–∏!`,
                {
                    title: '‚ö†Ô∏è –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è',
                    icon: 'üóëÔ∏è',
                    confirmText: '–¢–∞–∫, –≤–∏–¥–∞–ª–∏—Ç–∏',
                    cancelText: '–°–∫–∞—Å—É–≤–∞—Ç–∏',
                    danger: true
                }
            );
        }

        return confirm(`‚ö†Ô∏è –í–∏–¥–∞–ª–∏—Ç–∏ —Å–ø–æ–≥–∞–¥ "${memory.title}"?`);
    }

    // ========================================
    // –ü–û–®–£–ö –¢–ê –§–Ü–õ–¨–¢–†–ê–¶–Ü–Ø
    // ========================================

    searchMemories(query) {
        this.searchQuery = query.toLowerCase();
        this.refreshMemories();
    }

    filterByCategory(category) {
        this.filterCategory = category;
        this.refreshMemories();
    }

    filterByImportance(important) {
        this.filterImportant = important;
        this.refreshMemories();
    }

    setSortBy(sortBy) {
        this.sortBy = sortBy;
        this.refreshMemories();
    }

    getFilteredMemories() {
        let memories = this.getMemories();

        // –§—ñ–ª—å—Ç—Ä –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
        if (this.filterCategory !== 'all') {
            memories = memories.filter(m => m.category === this.filterCategory);
        }

        // –§—ñ–ª—å—Ç—Ä –∑–∞ –≤–∞–∂–ª–∏–≤—ñ—Å—Ç—é
        if (this.filterImportant) {
            memories = memories.filter(m => m.important);
        }

        // –ü–æ—à—É–∫
        if (this.searchQuery) {
            memories = memories.filter(m => {
                const searchText = (
                    m.title + ' ' + 
                    m.content + ' ' + 
                    (m.tags || []).join(' ')
                ).toLowerCase();
                return searchText.includes(this.searchQuery);
            });
        }

        // –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è
        memories = this.sortMemories(memories);

        return memories;
    }

    sortMemories(memories) {
        const sorted = [...memories];

        switch (this.sortBy) {
            case 'date':
                sorted.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                break;
            case 'importance':
                sorted.sort((a, b) => {
                    if (a.important === b.important) {
                        return (b.timestamp || 0) - (a.timestamp || 0);
                    }
                    return a.important ? -1 : 1;
                });
                break;
            case 'category':
                sorted.sort((a, b) => {
                    const catCompare = (a.category || '').localeCompare(b.category || '');
                    if (catCompare === 0) {
                        return (b.timestamp || 0) - (a.timestamp || 0);
                    }
                    return catCompare;
                });
                break;
        }

        return sorted;
    }

    // ========================================
    // –ï–ö–°–ü–û–†–¢ / –Ü–ú–ü–û–†–¢
    // ========================================

    async exportMemories(format = 'json') {
        const memories = this.getMemories();
        
        if (memories.length === 0) {
            if (window.showToast) {
                showToast('‚ö†Ô∏è –ù–µ–º–∞—î —Å–ø–æ–≥–∞–¥—ñ–≤ –¥–ª—è –µ–∫—Å–ø–æ—Ä—Ç—É', 'warning');
            }
            return;
        }

        let content = '';
        let filename = `memories-${Date.now()}`;

        if (format === 'json') {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                count: memories.length,
                memories: memories
            };
            content = JSON.stringify(data, null, 2);
            filename += '.json';
        } else if (format === 'markdown') {
            content = this.generateMarkdown(memories);
            filename += '.md';
        }

        this.downloadFile(content, filename);

        if (window.showToast) {
            showToast('‚úÖ –°–ø–æ–≥–∞–¥–∏ –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!', 'success');
        }
    }

    generateMarkdown(memories) {
        let md = `# üß† –°–ø–æ–≥–∞–¥–∏\n\n`;
        md += `–ï–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ: ${new Date().toLocaleString('uk-UA')}\n`;
        md += `–í—Å—å–æ–≥–æ —Å–ø–æ–≥–∞–¥—ñ–≤: ${memories.length}\n\n`;
        md += `---\n\n`;

        memories.forEach((memory, i) => {
            md += `## ${memory.important ? '‚≠ê ' : ''}${memory.title}\n\n`;
            md += `**–ö–∞—Ç–µ–≥–æ—Ä—ñ—è:** ${memory.category}\n\n`;
            md += `${memory.content}\n\n`;
            
            if (memory.tags && memory.tags.length > 0) {
                md += `**–¢–µ–≥–∏:** ${memory.tags.map(t => `#${t}`).join(', ')}\n\n`;
            }
            
            md += `*${new Date(memory.timestamp || memory.created).toLocaleString('uk-UA')}*\n\n`;
            
            if (i < memories.length - 1) {
                md += `---\n\n`;
            }
        });

        return md;
    }

    downloadFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async clearAllMemories() {
        if (!confirm('‚ö†Ô∏è –í–∏–¥–∞–ª–∏—Ç–∏ –í–°–Ü —Å–ø–æ–≥–∞–¥–∏? –¶—é –¥—ñ—é –Ω–µ –º–æ–∂–Ω–∞ —Å–∫–∞—Å—É–≤–∞—Ç–∏!')) {
            return false;
        }

        try {
            // –û—á–∏—Å—Ç–∏—Ç–∏ AppState
            if (window.appState && window.appState.agent) {
                window.appState.agent.memory = [];
            }

            // –û—á–∏—Å—Ç–∏—Ç–∏ IndexedDB
            if (window.storageManager) {
                await storageManager.clear(storageManager.stores.memories);
            }

            // –û—á–∏—Å—Ç–∏—Ç–∏ localStorage
            localStorage.removeItem('agent_memories');

            this.refreshMemories();

            if (window.showToast) {
                showToast('üóëÔ∏è –í—Å—ñ —Å–ø–æ–≥–∞–¥–∏ –≤–∏–¥–∞–ª–µ–Ω–æ', 'success');
            }

            return true;

        } catch (error) {
            console.error('Failed to clear memories:', error);
            if (window.showToast) {
                showToast('‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—á–∏—â–µ–Ω–Ω—è', 'error');
            }
            return false;
        }
    }

    // ========================================
    // –ê–í–¢–û–ú–ê–¢–ò–ß–ù–Ü –°–ü–û–ì–ê–î–ò
    // ========================================

    async autoRemember(type, data) {
        const titles = {
            plan_completed: `–ü–ª–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–æ: ${data.title}`,
            code_generated: `–ö–æ–¥ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ: ${data.filename}`,
            image_generated: `–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å—Ç–≤–æ—Ä–µ–Ω–æ`,
            conversation_saved: `–†–æ–∑–º–æ–≤–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–∞`
        };

        const memory = {
            id: Date.now(),
            title: titles[type] || '–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Å–ø–æ–≥–∞–¥',
            content: JSON.stringify(data, null, 2),
            category: '–∑–∞–≥–∞–ª—å–Ω–µ',
            important: false,
            tags: [type],
            timestamp: Date.now(),
            created: new Date().toISOString(),
            auto: true
        };

        try {
            if (window.appState) {
                appState.addMemory(memory);
            }

            if (window.storageManager) {
                await storageManager.saveMemory(memory);
            }

            await this.saveToLocalStorage();

            return memory;

        } catch (error) {
            console.error('Auto-remember failed:', error);
            return null;
        }
    }

    // ========================================
    // UTILITY –§–£–ù–ö–¶–Ü–á
    // ========================================

    getMemories() {
        if (window.appState) {
            return appState.getMemories() || [];
        }
        return [];
    }

    getMemory(memoryId) {
        const memories = this.getMemories();
        return memories.find(m => m.id === memoryId);
    }

    refreshMemories() {
        this.updateStats();
        
        // –°–ø–æ–≤—ñ—Å—Ç–∏—Ç–∏ UI
        if (window.eventBus) {
            eventBus.emit('memory:refresh');
        }
    }

    updateStats() {
        const memories = this.getMemories();

        const stats = {
            total: memories.length,
            important: memories.filter(m => m.important).length,
            byCategory: {}
        };

        this.categories.forEach(cat => {
            stats.byCategory[cat] = memories.filter(m => m.category === cat).length;
        });

        // –û–Ω–æ–≤–∏—Ç–∏ UI
        const totalEl = document.getElementById('totalMemories');
        const importantEl = document.getElementById('importantMemories');
        const countEl = document.getElementById('memoryCount');

        if (totalEl) totalEl.textContent = stats.total;
        if (importantEl) importantEl.textContent = stats.important;
        if (countEl) countEl.textContent = stats.total;

        return stats;
    }

    async saveToLocalStorage() {
        try {
            const memories = this.getMemories();
            localStorage.setItem('agent_memories', JSON.stringify(memories));
        } catch (e) {
            console.error('Failed to save to localStorage:', e);
        }
    }

    detectCategory(title, content) {
        const text = (title + ' ' + content).toLowerCase();
        
        if (text.includes('–≤–∞–∂–ª–∏–≤') || text.includes('—Ç–µ—Ä–º—ñ–Ω')) return '–≤–∞–∂–ª–∏–≤–µ';
        if (text.includes('–∑–∞–≤–¥–∞–Ω') || text.includes('—Ç—Ä–µ–±–∞')) return '–∑–∞–≤–¥–∞–Ω–Ω—è';
        if (text.includes('–Ω–∞–≤—á–∏') || text.includes('–≤–∏–≤—á–∏')) return '–Ω–∞–≤—á–∞–Ω–Ω—è';
        if (text.includes('–º—ñ–π') || text.includes('–æ—Å–æ–±–∏—Å—Ç')) return '–ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–µ';
        
        return '–∑–∞–≥–∞–ª—å–Ω–µ';
    }

    extractTags(text) {
        if (!text) return [];
        const tags = (text.match(/#[\w–∞-—è—ñ—ó—î]+/gi) || [])
            .map(t => t.substring(1).toLowerCase());
        return [...new Set(tags)];
    }

    validateMemoryData(data) {
        const errors = [];

        if (!data.title || data.title.trim() === '') {
            errors.push('–ù–∞–∑–≤–∞ —Å–ø–æ–≥–∞–¥—É –æ–±–æ–≤\'—è–∑–∫–æ–≤–∞');
        }

        if (data.title && data.title.length > 200) {
            errors.push('–ù–∞–∑–≤–∞ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∞');
        }

        if (!data.content || data.content.trim() === '') {
            errors.push('–í–º—ñ—Å—Ç —Å–ø–æ–≥–∞–¥—É –æ–±–æ–≤\'—è–∑–∫–æ–≤–∏–π');
        }

        return {
            valid: errors.length === 0,
            errors: errors
        };
    }

    closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            delete modal.dataset.editingId;
        }
    }

    getStats() {
        return this.updateStats();
    }
}

// ========================================
// –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø
// ========================================

const memoryManagerCore = new MemoryManagerCore();

// –ï–∫—Å–ø–æ—Ä—Ç
window.memoryManagerCore = memoryManagerCore;
window.MemoryManagerCore = MemoryManagerCore;

// Compatibility functions
window.addMemory = () => memoryManagerCore.openCreateModal();
window.saveMemory = () => memoryManagerCore.createMemory();
window.autoRemember = (type, data) => memoryManagerCore.autoRemember(type, data);

console.log('‚úÖ Memory Manager Core loaded');
