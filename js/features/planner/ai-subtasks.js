// ü§ñ AI Subtasks Generator (200 lines)

class AISubtasksGenerator {
    constructor() {
        this.apiEndpoint = 'https://api.groq.com/openai/v1/chat/completions';
        this.model = 'llama-3.3-70b-versatile';
        this.isGenerating = false;
        
        this.init();
    }

    // ========================================
    // –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø
    // ========================================

    init() {
        console.log('‚úÖ AI Subtasks Generator initialized');
    }

    // ========================================
    // –ì–ï–ù–ï–†–ê–¶–Ü–Ø –ü–Ü–î–ó–ê–í–î–ê–ù–¨
    // ========================================

    async generateSubtasks(planId) {
        if (this.isGenerating) {
            if (window.showToast) {
                showToast('‚è≥ AI –≤–∂–µ –≥–µ–Ω–µ—Ä—É—î –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è', 'warning');
            }
            return null;
        }

        const plan = this.getPlan(planId);
        if (!plan) {
            throw new Error('Plan not found');
        }

        // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ API –∫–ª—é—á
        const apiKey = this.getApiKey();
        if (!apiKey) {
            if (window.showToast) {
                showToast('üîë –í–≤–µ–¥–∏ Groq API –∫–ª—é—á —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö!', 'error');
            }
            if (typeof switchMode === 'function') {
                switchMode('settings');
            }
            return null;
        }

        this.isGenerating = true;

        if (window.showToast) {
            showToast('ü§ñ AI –≥–µ–Ω–µ—Ä—É—î –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è...', 'info', 3000);
        }

        try {
            // –°—Ç–≤–æ—Ä–∏—Ç–∏ prompt
            const prompt = this.buildPrompt(plan);

            // –í–∏–∫–ª–∏–∫–∞—Ç–∏ API
            const subtasksText = await this.callAPI(apiKey, prompt);

            // –ü–∞—Ä—Å–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            const subtasks = this.parseSubtasks(subtasksText);

            if (subtasks.length === 0) {
                throw new Error('AI –Ω–µ –∑–≥–µ–Ω–µ—Ä—É–≤–∞–≤ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è');
            }

            // –î–æ–¥–∞—Ç–∏ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è –¥–æ –ø–ª–∞–Ω—É
            if (window.taskManager) {
                await taskManager.addMultipleTasks(planId, subtasks);
            }

            // –ü–æ–∑–Ω–∞—á–∏—Ç–∏ —â–æ –ø–ª–∞–Ω –º–∞—î AI –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è
            if (window.plannerCore) {
                await plannerCore.updatePlan(planId, { aiGenerated: true });
            }

            if (window.showToast) {
                showToast(`‚úÖ AI —Å—Ç–≤–æ—Ä–∏–≤ ${subtasks.length} –ø—ñ–¥–∑–∞–≤–¥–∞–Ω—å!`, 'success');
            }

            return subtasks;

        } catch (error) {
            this.handleError(error);
            return null;
        } finally {
            this.isGenerating = false;
        }
    }

    // ========================================
    // PROMPT GENERATION
    // ========================================

    buildPrompt(plan) {
        let prompt = `–†–æ–∑–±–∏–π —Ü–µ –∑–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ, –≤–∏–∫–æ–Ω—É–≤–∞–Ω—ñ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è (–≤—ñ–¥ 3 –¥–æ 7 —à—Ç—É–∫):\n\n`;
        prompt += `–ó–∞–≤–¥–∞–Ω–Ω—è: ${plan.title}\n`;
        
        if (plan.description) {
            prompt += `–û–ø–∏—Å: ${plan.description}\n`;
        }

        if (plan.deadline) {
            const deadline = new Date(plan.deadline);
            prompt += `–î–µ–¥–ª–∞–π–Ω: ${deadline.toLocaleDateString('uk-UA')}\n`;
        }

        prompt += `\n–í–∏–º–æ–≥–∏:\n`;
        prompt += `- –ö–æ–∂–Ω–µ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è –º–∞—î –±—É—Ç–∏ —á—ñ—Ç–∫–∏–º —Ç–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º\n`;
        prompt += `- –ü—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è –º–∞—é—Ç—å –±—É—Ç–∏ –≤ –ª–æ–≥—ñ—á–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É –≤–∏–∫–æ–Ω–∞–Ω–Ω—è\n`;
        prompt += `- –ö–æ–∂–Ω–µ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è –º–∞—î –ø–æ—á–∏–Ω–∞—Ç–∏—Å—è –∑ –¥—ñ—î—Å–ª–æ–≤–∞\n`;
        prompt += `- –§–æ—Ä–º–∞—Ç: –æ–¥–∏–Ω –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ —Ä—è–¥–æ–∫, –±–µ–∑ –Ω—É–º–µ—Ä–∞—Ü—ñ—ó\n\n`;
        prompt += `–ü—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è:`;

        return prompt;
    }

    // ========================================
    // API CALL
    // ========================================

    async callAPI(apiKey, prompt) {
        const systemPrompt = '–¢–∏ –ø–æ–º—ñ—á–Ω–∏–∫ –¥–ª—è –ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω—å. –°—Ç–≤–æ—Ä—é–π —á—ñ—Ç–∫—ñ, –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é.';

        const requestBody = {
            model: this.model,
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: prompt }
            ],
            temperature: 0.7,
            max_tokens: 500,
            top_p: 0.9
        };

        try {
            let response;

            if (window.errorHandler) {
                response = await errorHandler.fetchWithRetry(
                    this.apiEndpoint,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody),
                        timeout: 30000
                    }
                );
            } else {
                response = await fetch(this.apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API Error: ${response.status}`);
                }
            }

            const data = await response.json();

            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid API response format');
            }

            return data.choices[0].message.content;

        } catch (error) {
            if (window.errorHandler) {
                errorHandler.logError({
                    type: 'ai_subtasks_error',
                    message: 'Failed to generate subtasks',
                    error: error.message,
                    severity: 'medium'
                });
            }
            throw error;
        }
    }

    // ========================================
    // –ü–ê–†–°–ò–ù–ì –†–ï–ó–£–õ–¨–¢–ê–¢–£
    // ========================================

    parseSubtasks(text) {
        if (!text) return [];

        const lines = text
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .map(line => {
                // –í–∏–¥–∞–ª–∏—Ç–∏ –Ω—É–º–µ—Ä–∞—Ü—ñ—é, –º–∞—Ä–∫–µ—Ä–∏, —Ç–æ—â–æ
                return line
                    .replace(/^[-‚Ä¢*\d.)\]]+\s*/, '')
                    .replace(/^\[[\sx]\]\s*/, '')
                    .trim();
            })
            .filter(line => {
                // –§—ñ–ª—å—Ç—Ä—É–≤–∞—Ç–∏ –ø–æ—Ä–æ–∂–Ω—ñ —Ç–∞ –∑–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫—ñ
                return line.length > 3 && line.length < 200;
            });

        // –û–±–º–µ–∂–∏—Ç–∏ –¥–æ 10 –ø—ñ–¥–∑–∞–≤–¥–∞–Ω—å
        return lines.slice(0, 10);
    }

    // ========================================
    // –ü–û–ö–†–ê–©–ï–ù–ù–Ø –Ü–°–ù–£–Æ–ß–ò–• –ü–Ü–î–ó–ê–í–î–ê–ù–¨
    // ========================================

    async improveSubtasks(planId) {
        const plan = this.getPlan(planId);
        if (!plan || !plan.subtasks || plan.subtasks.length === 0) {
            if (window.showToast) {
                showToast('‚ö†Ô∏è –ù–µ–º–∞—î –ø—ñ–¥–∑–∞–≤–¥–∞–Ω—å –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è', 'warning');
            }
            return null;
        }

        const apiKey = this.getApiKey();
        if (!apiKey) return null;

        this.isGenerating = true;

        try {
            const prompt = this.buildImprovementPrompt(plan);
            const improvedText = await this.callAPI(apiKey, prompt);
            const improvedSubtasks = this.parseSubtasks(improvedText);

            if (improvedSubtasks.length === 0) {
                throw new Error('AI –Ω–µ –ø–æ–∫—Ä–∞—â–∏–≤ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è');
            }

            // –ó–∞–º—ñ–Ω–∏—Ç–∏ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è
            if (window.plannerCore) {
                await plannerCore.updatePlan(planId, {
                    subtasks: improvedSubtasks.map(title => ({
                        id: Date.now() + Math.random(),
                        title: title,
                        completed: false,
                        created: new Date().toISOString()
                    }))
                });
            }

            if (window.showToast) {
                showToast('‚úÖ AI –ø–æ–∫—Ä–∞—â–∏–≤ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è!', 'success');
            }

            return improvedSubtasks;

        } catch (error) {
            this.handleError(error);
            return null;
        } finally {
            this.isGenerating = false;
        }
    }

    buildImprovementPrompt(plan) {
        let prompt = `–ü–æ–∫—Ä–∞—â —Ü—ñ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è, –∑—Ä–æ–±–∏ —ó—Ö –±—ñ–ª—å—à –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º–∏ —Ç–∞ –≤–∏–∫–æ–Ω—É–≤–∞–Ω–∏–º–∏:\n\n`;
        prompt += `–ó–∞–≤–¥–∞–Ω–Ω—è: ${plan.title}\n\n`;
        prompt += `–ü–æ—Ç–æ—á–Ω—ñ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è:\n`;
        
        plan.subtasks.forEach((task, i) => {
            prompt += `${i + 1}. ${task.title}\n`;
        });

        prompt += `\n–ü–æ–∫—Ä–∞—â–µ–Ω—ñ –ø—ñ–¥–∑–∞–≤–¥–∞–Ω–Ω—è:`;

        return prompt;
    }

    // ========================================
    // ERROR HANDLING
    // ========================================

    handleError(error) {
        console.error('AI subtasks generation error:', error);

        let message = '‚ùå –ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó: ';

        if (error.message.includes('API key')) {
            message += '–ù–µ–≤—ñ—Ä–Ω–∏–π API –∫–ª—é—á';
        } else if (error.message.includes('quota')) {
            message += '–ü–µ—Ä–µ–≤–∏—â–µ–Ω–æ –ª—ñ–º—ñ—Ç –∑–∞–ø–∏—Ç—ñ–≤';
        } else if (error.message.includes('network')) {
            message += '–ü—Ä–æ–±–ª–µ–º–∏ –∑ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç–æ–º';
        } else {
            message += error.message || '–©–æ—Å—å –ø—ñ—à–ª–æ –Ω–µ —Ç–∞–∫';
        }

        if (window.showToast) {
            showToast(message, 'error', 7000);
        }
    }

    // ========================================
    // UTILITY
    // ========================================

    getPlan(planId) {
        const plans = window.appState ? appState.getPlans() : [];
        return plans.find(p => p.id === planId);
    }

    getApiKey() {
        if (typeof getGroqApiKey === 'function') {
            return getGroqApiKey();
        }

        if (window.appState) {
            return appState.getApiKey('groq');
        }

        return localStorage.getItem('groq_api_key');
    }

    getStatus() {
        return {
            isGenerating: this.isGenerating,
            model: this.model
        };
    }
}

// ========================================
// –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø
// ========================================

const aiSubtasksGenerator = new AISubtasksGenerator();

// –ï–∫—Å–ø–æ—Ä—Ç
window.aiSubtasksGenerator = aiSubtasksGenerator;
window.AISubtasksGenerator = AISubtasksGenerator;

// Compatibility function
window.generateSubtasks = (planId) => aiSubtasksGenerator.generateSubtasks(planId);

console.log('‚úÖ AI Subtasks Generator loaded');
